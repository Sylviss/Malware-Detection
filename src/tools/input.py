import pefile,os,datetime,math,yara
import tqdm
PE_EXTENSION = ['','.acm', '.ax', '.cpl', '.dll', '.drv', '.efi', '.exe', '.mui', '.ocx', '.scr', '.sys', '.tsp', '.mun']
SECTION_NAME = [".text",".data",".rdata",".idata",".edata",".pdata",".rsrc",".reloc",".tls", ".bss", "UPX0", "UPX1", "UPX2"]
rules = yara.compile(filepath='./tools/peid.yara')

def shannon_entropy(data):
    # 256 different possible values
    possible = dict(((chr(x), 0) for x in range(0, 256)))

    for byte in data:
        possible[chr(byte)] +=1

    data_len = len(data)
    entropy = 0.0

    # compute
    for i in possible:
        if possible[i] == 0:
            continue

        p = float(possible[i] / data_len)
        entropy -= p * math.log(p, 2)
    return entropy


def input_single_file_2(file_path):
    try:
        res = {"pe_header":{},"pe_sections":{}}
        pe = pefile.PE(file_path, fast_load=True)
        pe.parse_data_directories()
    except pefile.PEFormatError as err:
        print(file_path + " error" + repr(err))
        return {}
    try:
        dos_header_attributes = {
            "e_cblp": pe.DOS_HEADER.e_cblp,
            "e_cp": pe.DOS_HEADER.e_cp,
            "e_cparhdr": pe.DOS_HEADER.e_cparhdr,
            "e_maxalloc": pe.DOS_HEADER.e_maxalloc,
            "e_sp": pe.DOS_HEADER.e_sp,
            "e_lfanew": pe.DOS_HEADER.e_lfanew,
        }
    except AttributeError:
        dos_header_attributes = {
            "e_cblp": 0,
            "e_cp": 0,
            "e_cparhdr": 0,
            "e_maxalloc": 0,
            "e_sp": 0,
            "e_lfanew": 0
        }
    
    file_header_attributes = {
        "NumberOfSections": pe.FILE_HEADER.NumberOfSections,
        "CreationYear": file_creation_year(pe.FILE_HEADER.TimeDateStamp),
        "FH_char0": pe.FILE_HEADER.Characteristics & 0x0001,
        "FH_char1": pe.FILE_HEADER.Characteristics & 0x0002,
        "FH_char2": pe.FILE_HEADER.Characteristics & 0x0004,
        "FH_char3": pe.FILE_HEADER.Characteristics & 0x0008,
        "FH_char4": pe.FILE_HEADER.Characteristics & 0x0010,
        "FH_char5": pe.FILE_HEADER.Characteristics & 0x0020,
        "FH_char6": pe.FILE_HEADER.Characteristics & 0x0040,
        "FH_char7": pe.FILE_HEADER.Characteristics & 0x0080,
        "FH_char8": pe.FILE_HEADER.Characteristics & 0x0100,
        "FH_char9": pe.FILE_HEADER.Characteristics & 0x0200,
        "FH_char10": pe.FILE_HEADER.Characteristics & 0x0400,
        "FH_char11": pe.FILE_HEADER.Characteristics & 0x0800,
        "FH_char12": pe.FILE_HEADER.Characteristics & 0x1000,
        "FH_char13": pe.FILE_HEADER.Characteristics & 0x2000,
        "FH_char14": pe.FILE_HEADER.Characteristics & 0x4000
    }
    baseofdata=0
    if hasattr(pe.OPTIONAL_HEADER,"BaseOfData"):
        baseofdata = pe.OPTIONAL_HEADER.BaseOfData
    optional_header_attributes = {
        "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
        "MinorLinkerVersion": pe.OPTIONAL_HEADER.MinorLinkerVersion,
        "SizeOfCode": pe.OPTIONAL_HEADER.SizeOfCode,
        "SizeOfInitializedData": pe.OPTIONAL_HEADER.SizeOfInitializedData,
        "SizeOfUninitializedData": pe.OPTIONAL_HEADER.SizeOfUninitializedData,
        "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
        "BaseOfCode": pe.OPTIONAL_HEADER.BaseOfCode,
        "BaseOfData": baseofdata,
        "ImageBase": Optional_header_ImageBase(pe.OPTIONAL_HEADER.ImageBase),
        "SectionAlignment": Optional_header_SectionAlignment(pe.OPTIONAL_HEADER.SectionAlignment,pe.OPTIONAL_HEADER.FileAlignment),
        "FileAlignment": Optional_header_FileAlignment(pe.OPTIONAL_HEADER.SectionAlignment,pe.OPTIONAL_HEADER.FileAlignment),
        "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        "MinorOperatingSystemVersion": pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
        "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
        "MinorImageVersion": pe.OPTIONAL_HEADER.MinorImageVersion,
        "MajorSubsystemVersion": pe.OPTIONAL_HEADER.MajorSubsystemVersion,
        "MinorSubsystemVersion": pe.OPTIONAL_HEADER.MinorSubsystemVersion,
        "SizeOfImage": Optional_header_SizeOfImage(pe.OPTIONAL_HEADER.SizeOfImage,pe.OPTIONAL_HEADER.SectionAlignment),
        "SizeOfHeaders": Optional_header_SizeOfHeaders(pe.OPTIONAL_HEADER.SizeOfHeaders,pe.OPTIONAL_HEADER.FileAlignment),
        "CheckSum": pe.OPTIONAL_HEADER.CheckSum,
        "Subsystem": pe.OPTIONAL_HEADER.Subsystem,
        "OH_DLL": pe.OPTIONAL_HEADER.DllCharacteristics & 0x2000,
        "OH_char1": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0001,
        "OH_char2": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0002,
        "OH_char3": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0004,
        "OH_char4": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0008,
        "OH_char5": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0010,
        "OH_char6": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0020,
        "OH_char7": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040,
        "OH_char8": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0080,
        "OH_char9": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100,
        "OH_char10": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0200,
        "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
        "SizeOfStackCommit": pe.OPTIONAL_HEADER.SizeOfStackCommit,
        "SizeOfHeapReserve": pe.OPTIONAL_HEADER.SizeOfHeapReserve,
        "SizeOfHeapCommit": pe.OPTIONAL_HEADER.SizeOfHeapCommit,
        "LoaderFlags": pe.OPTIONAL_HEADER.LoaderFlags
    }
    count = get_count_suspicious_sections(pe)
    packer = check_packer(file_path)
    text_data_entropy = get_text_data_entropy(pe)
    entropy_size = get_file_entropy(file_path)
    info = get_fileinfo(pe)
    derived_attributes = {
        "sus_sections": count[0],
        "non_sus_sections": count[1],
        "packer": packer[0],
        "packer_type": packer[1],
        "E_text": text_data_entropy[0],
        "E_data": text_data_entropy[1],
        "file_size": entropy_size[0],
        "entropy": entropy_size[1],
        "fileinfo": info
    }
    
    res["pe_header"].update(dos_header_attributes)
    res["pe_header"].update(file_header_attributes)
    res["pe_header"].update(optional_header_attributes)
    res["pe_header"].update(derived_attributes)
    return {file_path:res} 

def input_single_file_1(file_path):
    try:
        res = {"pe_header":{},"pe_sections":{}}
        pe = pefile.PE(file_path, fast_load=True)
        pe.parse_data_directories()
    except pefile.PEFormatError:
        return {}
    # for section in pe.sections:
    #     try:
    #         section_name = str(section.Name, encoding='utf-8').rstrip('\x00')
    #         if section_name in SECTION_NAME:
    #             res["pe_sections"].update({
    #                 section_name + "_Misc_VirtualSize" : section.Misc_VirtualSize,
    #                 section_name + "_VirtualAddress" : section.VirtualAddress,
    #                 section_name + "_SizeOfRawData" : section.SizeOfRawData,
                    # section_name + "_PointerToRawData" : section.PointerToRawData,
                    # section_name + "_PointerToRelocations" : section.PointerToRelocations,
                    # section_name + "_PointerToLinenumbers" : section.PointerToLinenumbers,
                    # section_name + "_NumberOfRelocations" : section.NumberOfRelocations,
                    # section_name + "_NumberOfLinenumbers" : section.NumberOfLinenumbers,
                    # section_name + "_Charateristics" : section.Characteristics
    #             })
    #             res["pe_sections"].update({
    #                 section_name + "_Entropy" : shannon_entropy(section.get_data())
    #             })
    #     except UnicodeDecodeError:
    #         continue
    # for section_name in SECTION_NAME:
    #     if (section_name + "_Misc_VirtualSize") not in res["pe_sections"]:
    #         res["pe_sections"].update({
    #             section_name + "_Misc_VirtualSize" : 0,
    #             section_name + "_VirtualAddress" : 0,
    #             section_name + "_SizeOfRawData" : 0,
                # section_name + "_PointerToRawData" : 0,
                # section_name + "_PointerToRelocations" : 0,
                # section_name + "_PointerToLinenumbers" : 0,
                # section_name + "_NumberOfRelocations" : 0,
                # section_name + "_NumberOfLinenumbers" : 0,
                # section_name + "_Charateristics" : 0,
            #     section_name + "_Entropy" : 0
            # })
    try:
        dos_header_attributes = {
            "e_magic": pe.DOS_HEADER.e_magic,
            "e_cblp": pe.DOS_HEADER.e_cblp,
            "e_cp": pe.DOS_HEADER.e_cp,
            "e_crlc": pe.DOS_HEADER.e_crlc,
            "e_cparhdr": pe.DOS_HEADER.e_cparhdr,
            "e_minalloc": pe.DOS_HEADER.e_minalloc,
            "e_maxalloc": pe.DOS_HEADER.e_maxalloc,
            "e_ss": pe.DOS_HEADER.e_ss,
            "e_sp": pe.DOS_HEADER.e_sp,
            "e_csum": pe.DOS_HEADER.e_csum,
            "e_ip": pe.DOS_HEADER.e_ip,
            "e_cs": pe.DOS_HEADER.e_cs,
            "e_lfarlc": pe.DOS_HEADER.e_lfarlc,
            "e_ovno": pe.DOS_HEADER.e_ovno,
            "e_oemid": pe.DOS_HEADER.e_oemid,
            "e_oeminfo": pe.DOS_HEADER.e_oeminfo,
            "e_lfanew": pe.DOS_HEADER.e_lfanew,
        }
    except AttributeError:
        dos_header_attributes = {
            "e_magic": 0,
            "e_cblp": 0,
            "e_cp": 0,
            "e_crlc": 0,
            "e_cparhdr": 0,
            "e_minalloc": 0,
            "e_maxalloc": 0,
            "e_ss": 0,
            "e_sp": 0,
            "e_csum": 0,
            "e_ip": 0,
            "e_cs": 0,
            "e_lfarlc": 0,
            "e_ovno": 0,
            "e_oemid": 0,
            "e_oeminfo": 0,
            "e_lfanew": 0
        }
    
    file_header_attributes = {
        "Machine": pe.FILE_HEADER.Machine,
        "NumberOfSections": pe.FILE_HEADER.NumberOfSections,
        "CreationYear": datetime.date.fromtimestamp(pe.FILE_HEADER.TimeDateStamp).year,
        "PointerToSymbolTable": pe.FILE_HEADER.PointerToSymbolTable,
        "NumberOfSymbols": pe.FILE_HEADER.NumberOfSymbols,
        "SizeOfOptionalHeader": pe.FILE_HEADER.SizeOfOptionalHeader,
        "Characteristics": pe.FILE_HEADER.Characteristics
    }
    baseofdata=0
    if hasattr(pe.OPTIONAL_HEADER,"BaseOfData"):
        baseofdata = pe.OPTIONAL_HEADER.BaseOfData
    optional_header_attributes = {
        "Magic": pe.OPTIONAL_HEADER.Magic,
        "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
        "MinorLinkerVersion": pe.OPTIONAL_HEADER.MinorLinkerVersion,
        "SizeOfCode": pe.OPTIONAL_HEADER.SizeOfCode,
        "SizeOfInitializedData": pe.OPTIONAL_HEADER.SizeOfInitializedData,
        "SizeOfUninitializedData": pe.OPTIONAL_HEADER.SizeOfUninitializedData,
        "AddressOfEntryPoint": pe.OPTIONAL_HEADER.AddressOfEntryPoint,
        "BaseOfCode": pe.OPTIONAL_HEADER.BaseOfCode,
        "BaseOfData": baseofdata,
        "ImageBase": pe.OPTIONAL_HEADER.ImageBase,
        "SectionAlignment": pe.OPTIONAL_HEADER.SectionAlignment,
        "FileAlignment": pe.OPTIONAL_HEADER.FileAlignment,
        "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        "MinorOperatingSystemVersion": pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
        "MajorImageVersion": pe.OPTIONAL_HEADER.MajorImageVersion,
        "MinorImageVersion": pe.OPTIONAL_HEADER.MinorImageVersion,
        "MajorSubsystemVersion": pe.OPTIONAL_HEADER.MajorSubsystemVersion,
        "MinorSubsystemVersion": pe.OPTIONAL_HEADER.MinorSubsystemVersion,
        "SizeOfImage": pe.OPTIONAL_HEADER.SizeOfImage,
        "SizeOfHeaders": pe.OPTIONAL_HEADER.SizeOfHeaders,
        "CheckSum": pe.OPTIONAL_HEADER.CheckSum,
        "Subsystem": pe.OPTIONAL_HEADER.Subsystem,
        "DllCharacteristics": pe.OPTIONAL_HEADER.DllCharacteristics,
        "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
        "SizeOfStackCommit": pe.OPTIONAL_HEADER.SizeOfStackCommit,
        "SizeOfHeapReserve": pe.OPTIONAL_HEADER.SizeOfHeapReserve,
        "SizeOfHeapCommit": pe.OPTIONAL_HEADER.SizeOfHeapCommit,
        "LoaderFlags": pe.OPTIONAL_HEADER.LoaderFlags,
        "NumberOfRvaAndSizes": pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
    }

    res["pe_header"].update(dos_header_attributes)
    res["pe_header"].update(file_header_attributes)
    res["pe_header"].update(optional_header_attributes)
    return {file_path:res}

def input_directories(path,type):
    res = {}
    for root, _, files in os.walk(path):
        for file in files:
            # print(file)
            file_name = os.path.join(root, file)
            file_extension = os.path.splitext(file_name)[1]
            # print(file_extension)
            if file_extension in PE_EXTENSION or len(file_extension)>10:
                if type == 1:
                    res.update(input_single_file_1(file_name))
                else:
                    res.update(input_single_file_2(file_name))
    return res 

def file_creation_year(seconds):
    tmp = 1970 + ((int(seconds) / 86400) / 365)
    return int(tmp in range (1980,2023)) 
    
def Optional_header_ImageBase(ImageBase):
    result= 0
    if ImageBase % (64 * 1024) == 0 and ImageBase in [268435456,65536,4194304]:
        result = 1
    return result
    
def Optional_header_SectionAlignment(SectionAlignment,FileAlignment):
    """This is boolean function and will return 0 or 1 based on condidtions
    that it SectionAlignment must be greater than or equal to FileAlignment
    """
    return int(SectionAlignment >= FileAlignment)
    
def Optional_header_FileAlignment(SectionAlignment,FileAlignment):
    result =0
    if SectionAlignment >= 512:
        if FileAlignment % 2 == 0 and FileAlignment in range(512,65537):
            result =1
    else: 
        if FileAlignment == SectionAlignment:
            result = 1
    return result
    
def Optional_header_SizeOfImage(SizeOfImage,SectionAlignment):
    return int(SizeOfImage % SectionAlignment == 0)

def Optional_header_SizeOfHeaders(SizeOfHeaders,FileAlignment):
    return int(SizeOfHeaders % FileAlignment == 0 )

def get_count_suspicious_sections(pe):
    result=[]
    tmp =[]
    benign_sections = set(['.text','.data','.rdata','.idata','.edata','.rsrc','.bss','.crt','.tls'])
    for section in pe.sections:
        try:
            tmp.append(str(section.Name, encoding='utf-8').split('\x00')[0])
        except UnicodeDecodeError:
            tmp.append("THIS IS AN EASTER EGG")
    non_sus_sections = len(set(tmp).intersection(benign_sections))
    result=[len(tmp) - non_sus_sections, non_sus_sections]
    return result

def check_packer(filepath):
    matches = rules.match(filepath)
    if matches == []:
        result=[0,"NoPacker"]
    else:
        result=[1,matches[0]]
    return result

def get_text_data_entropy(pe):
    result=[0.0,0.0]
    for section in pe.sections:
        try:
            s_name = str(section.Name, encoding='utf-8').split('\x00')[0]
        except UnicodeDecodeError:
            continue
        if s_name == ".text":
            result[0]= section.get_entropy()
        elif s_name == ".data":
            result[1]= section.get_entropy()
        else:
            pass
    return result  

def get_file_bytes_size(filepath):
    with open(filepath, "rb") as f:
        byteArr = f.read()
        fileSize = len(byteArr)
    return byteArr,fileSize

def cal_byteFrequency(byteArr,fileSize):
    freqList = {a:0 for a in range(256)}
    for byte in byteArr:
        if int(byte)<256:
            freqList[int(byte)]+=1
    for byte in freqList:
        freqList[byte]/=fileSize
    return list(freqList.values())

def get_file_entropy(filepath):
    byteArr, fileSize = get_file_bytes_size(filepath)
    freqList = cal_byteFrequency(byteArr,fileSize)
    ent = 0.0
    for freq in freqList:
        if freq > 0:
            ent +=  - freq * math.log(freq, 2)
    return [fileSize,ent]

def get_fileinfo(pe):
    result=[]
    try:
        string_version_info = {}
        for fileinfo in pe.FileInfo[0]:
            if fileinfo.Key.decode() == 'StringFileInfo':
                for st in fileinfo.StringTable:
                    for entry in st.entries.items():
                        string_version_info[entry[0].decode()] = entry[1].decode()
        FileVersion    = string_version_info["FileVersion"]
        ProductVersion = string_version_info["ProductVersion"]
        ProductName =   string_version_info["ProductName"]
        CompanyName = string_version_info["CompanyName"]
        if type([pe.VS_FIXEDFILEINFO]) == type([]):
            FileVersionLS    = pe.VS_FIXEDFILEINFO[0].FileVersionLS
            FileVersionMS    = pe.VS_FIXEDFILEINFO[0].FileVersionMS
            ProductVersionLS = pe.VS_FIXEDFILEINFO[0].ProductVersionLS
            ProductVersionMS = pe.VS_FIXEDFILEINFO[0].ProductVersionMS
        else:
            FileVersionLS    = pe.VS_FIXEDFILEINFO.FileVersionLS
            FileVersionMS    = pe.VS_FIXEDFILEINFO.FileVersionMS
            ProductVersionLS = pe.VS_FIXEDFILEINFO.ProductVersionLS
            ProductVersionMS = pe.VS_FIXEDFILEINFO.ProductVersionMS
    except Exception as e:
        result=["error"]
    else:
        FileVersion = (FileVersionMS >> 16, FileVersionMS & 0xFFFF, FileVersionLS >> 16, FileVersionLS & 0xFFFF)
        ProductVersion = (ProductVersionMS >> 16, ProductVersionMS & 0xFFFF, ProductVersionLS >> 16, ProductVersionLS & 0xFFFF)
        result = [FileVersion,ProductVersion,ProductName,CompanyName]
    return int ( result[0] != 'error')

if __name__ == "__main__":
    rules = yara.compile(filepath='./src/tools/peid.yara')
    file_name = r"C:\Users\tungv\Desktop\A lotz of shortcut\temp\A lot of malware\The-MALWARE-Repo-master\Worm"
    print(input_directories(file_name,2).keys())