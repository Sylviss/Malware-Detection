import pefile,os,datetime,math
PE_EXTENSION = ['','.acm', '.ax', '.cpl', '.dll', '.drv', '.efi', '.exe', '.mui', '.ocx', '.scr', '.sys', '.tsp', '.mun']
SECTION_NAME = [".text",".data",".rdata",".idata",".edata",".pdata",".rsrc",".reloc",".tls", ".bss", "UPX0", "UPX1", "UPX2"]

def shannon_entropy(data):
    # 256 different possible values
    possible = dict(((chr(x), 0) for x in range(0, 256)))

    for byte in data:
        possible[chr(byte)] +=1

    data_len = len(data)
    entropy = 0.0

    # compute
    for i in possible:
        if possible[i] == 0:
            continue

        p = float(possible[i] / data_len)
        entropy -= p * math.log(p, 2)
    return entropy

def input_single_file_3(file_path):
    try:
        res = {"pe_header":{},"pe_sections":{}}
        pe = pefile.PE(file_path, fast_load=True)
        pe.parse_data_directories()
    except pefile.PEFormatError as err:
        print(file_path + " error" + repr(err))
        return {}
    try:
        dos_header_attributes = {
            "e_maxalloc": pe.DOS_HEADER.e_maxalloc,
            "e_lfanew": pe.DOS_HEADER.e_lfanew,
        }
    except AttributeError:
        dos_header_attributes = {
            "e_maxalloc": 0,
            "e_lfanew": 0
        }
    
    file_header_attributes = {
        "NumberOfSections": pe.FILE_HEADER.NumberOfSections,
        "FH_char0": pe.FILE_HEADER.Characteristics & 0x0001,
        "FH_char2": pe.FILE_HEADER.Characteristics & 0x0004,
        "FH_char3": pe.FILE_HEADER.Characteristics & 0x0008,
        "FH_char5": pe.FILE_HEADER.Characteristics & 0x0020,
        "FH_char6": pe.FILE_HEADER.Characteristics & 0x0040,
        "FH_char8": pe.FILE_HEADER.Characteristics & 0x0100,
        "FH_char9": pe.FILE_HEADER.Characteristics & 0x0200,
        "FH_char10": pe.FILE_HEADER.Characteristics & 0x0400,
        "FH_char12": pe.FILE_HEADER.Characteristics & 0x1000,
        "FH_char14": pe.FILE_HEADER.Characteristics & 0x4000
    }
    baseofdata=0
    if hasattr(pe.OPTIONAL_HEADER,"BaseOfData"):
        baseofdata = pe.OPTIONAL_HEADER.BaseOfData
    optional_header_attributes = {
        "MajorLinkerVersion": pe.OPTIONAL_HEADER.MajorLinkerVersion,
        "MinorLinkerVersion": pe.OPTIONAL_HEADER.MinorLinkerVersion,
        "BaseOfData": baseofdata,
        "ImageBase": Optional_header_ImageBase(pe.OPTIONAL_HEADER.ImageBase),
        "MajorOperatingSystemVersion": pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        "MinorOperatingSystemVersion": pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
        "MajorSubsystemVersion": pe.OPTIONAL_HEADER.MajorSubsystemVersion,
        "MinorSubsystemVersion": pe.OPTIONAL_HEADER.MinorSubsystemVersion,
        "SizeOfImage": Optional_header_SizeOfImage(pe.OPTIONAL_HEADER.SizeOfImage,pe.OPTIONAL_HEADER.SectionAlignment),
        "SizeOfHeaders": Optional_header_SizeOfHeaders(pe.OPTIONAL_HEADER.SizeOfHeaders,pe.OPTIONAL_HEADER.FileAlignment),
        "Subsystem": pe.OPTIONAL_HEADER.Subsystem,
        "OH_DLLchar0": pe.OPTIONAL_HEADER.DllCharacteristics & 0x2000,
        "OH_DLLchar1": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0001,
        "OH_DLLchar2": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0002,
        "OH_DLLchar4": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0008,
        "OH_DLLchar7": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040,
        "OH_DLLchar8": pe.OPTIONAL_HEADER.DllCharacteristics & 0x0080,
        "SizeOfStackReserve": pe.OPTIONAL_HEADER.SizeOfStackReserve,
        "SizeOfHeapReserve": pe.OPTIONAL_HEADER.SizeOfHeapReserve,
        "SizeOfHeapCommit": pe.OPTIONAL_HEADER.SizeOfHeapCommit
    }
    count = get_count_suspicious_sections(pe)
    packer = check_packer(file_path)
    text_data_entropy = get_text_data_entropy(pe)
    entropy_size = get_file_entropy(file_path)
    info = get_fileinfo(pe)
    derived_attributes = {
        "sus_sections": count[0],
        "non_sus_sections": count[1],
        "E_text": text_data_entropy[0],
        "E_data": text_data_entropy[1],
        "file_size": entropy_size[0],
        "E_file": entropy_size[1],
        "fileinfo": info
    }
    
    res["pe_header"].update(dos_header_attributes)
    res["pe_header"].update(file_header_attributes)
    res["pe_header"].update(optional_header_attributes)
    res["pe_header"].update(derived_attributes)
    return {file_path:res} 

def input_directories(path,type, number=99999):
    res = {}
    count=0
    for root, _, files in os.walk(path):
        for file in files:
            # print(file)
            file_name = os.path.join(root, file)
            file_extension = os.path.splitext(file_name)[1]
            # print(file_extension)
            if file_extension in PE_EXTENSION or len(file_extension)>10:
                res.update(input_single_file_3(file_name))
                count+=1
                if count>number:
                    return res
    return res 

def file_creation_year(seconds):
    tmp = 1970 + ((int(seconds) / 86400) / 365)
    return int(tmp in range (1980,2023)) 
    
def Optional_header_ImageBase(ImageBase):
    result= 0
    if ImageBase % (64 * 1024) == 0 and ImageBase in [268435456,65536,4194304]:
        result = 1
    return result
    
def Optional_header_SectionAlignment(SectionAlignment,FileAlignment):
    """This is boolean function and will return 0 or 1 based on condidtions
    that it SectionAlignment must be greater than or equal to FileAlignment
    """
    return int(SectionAlignment >= FileAlignment)
    
def Optional_header_FileAlignment(SectionAlignment,FileAlignment):
    result =0
    if SectionAlignment >= 512:
        if FileAlignment % 2 == 0 and FileAlignment in range(512,65537):
            result =1
    else: 
        if FileAlignment == SectionAlignment:
            result = 1
    return result
    
def Optional_header_SizeOfImage(SizeOfImage,SectionAlignment):
    return int(SizeOfImage % SectionAlignment == 0)

def Optional_header_SizeOfHeaders(SizeOfHeaders,FileAlignment):
    return int(SizeOfHeaders % FileAlignment == 0 )

def get_count_suspicious_sections(pe):
    result=[]
    tmp =[]
    benign_sections = set(['.text','.data','.rdata','.idata','.edata','.rsrc','.bss','.crt','.tls'])
    for section in pe.sections:
        try:
            tmp.append(str(section.Name, encoding='utf-8').split('\x00')[0])
        except UnicodeDecodeError:
            tmp.append("THIS IS AN EASTER EGG")
    non_sus_sections = len(set(tmp).intersection(benign_sections))
    result=[len(tmp) - non_sus_sections, non_sus_sections]
    return result

def get_text_data_entropy(pe):
    result=[0.0,0.0]
    for section in pe.sections:
        try:
            s_name = str(section.Name, encoding='utf-8').split('\x00')[0]
        except UnicodeDecodeError:
            continue
        if s_name == ".text":
            result[0]= section.get_entropy()
        elif s_name == ".data":
            result[1]= section.get_entropy()
        else:
            pass
    return result  

def get_file_bytes_size(filepath):
    with open(filepath, "rb") as f:
        byteArr = f.read()
        fileSize = len(byteArr)
    return byteArr,fileSize

def cal_byteFrequency(byteArr,fileSize):
    freqList = {a:0 for a in range(256)}
    for byte in byteArr:
        if int(byte)<256:
            freqList[int(byte)]+=1
    for byte in freqList:
        freqList[byte]/=fileSize
    return list(freqList.values())

def get_file_entropy(filepath):
    byteArr, fileSize = get_file_bytes_size(filepath)
    freqList = cal_byteFrequency(byteArr,fileSize)
    ent = 0.0
    for freq in freqList:
        if freq > 0:
            ent +=  - freq * math.log(freq, 2)
    return [fileSize,ent]

def get_fileinfo(pe):
    result=[]
    try:
        string_version_info = {}
        for fileinfo in pe.FileInfo[0]:
            if fileinfo.Key.decode() == 'StringFileInfo':
                for st in fileinfo.StringTable:
                    for entry in st.entries.items():
                        string_version_info[entry[0].decode()] = entry[1].decode()
        FileVersion    = string_version_info["FileVersion"]
        ProductVersion = string_version_info["ProductVersion"]
        ProductName =   string_version_info["ProductName"]
        CompanyName = string_version_info["CompanyName"]
        if type([pe.VS_FIXEDFILEINFO]) == type([]):
            FileVersionLS    = pe.VS_FIXEDFILEINFO[0].FileVersionLS
            FileVersionMS    = pe.VS_FIXEDFILEINFO[0].FileVersionMS
            ProductVersionLS = pe.VS_FIXEDFILEINFO[0].ProductVersionLS
            ProductVersionMS = pe.VS_FIXEDFILEINFO[0].ProductVersionMS
        else:
            FileVersionLS    = pe.VS_FIXEDFILEINFO.FileVersionLS
            FileVersionMS    = pe.VS_FIXEDFILEINFO.FileVersionMS
            ProductVersionLS = pe.VS_FIXEDFILEINFO.ProductVersionLS
            ProductVersionMS = pe.VS_FIXEDFILEINFO.ProductVersionMS
    except Exception as e:
        result=["error"]
    else:
        FileVersion = (FileVersionMS >> 16, FileVersionMS & 0xFFFF, FileVersionLS >> 16, FileVersionLS & 0xFFFF)
        ProductVersion = (ProductVersionMS >> 16, ProductVersionMS & 0xFFFF, ProductVersionLS >> 16, ProductVersionLS & 0xFFFF)
        result = [FileVersion,ProductVersion,ProductName,CompanyName]
    return int ( result[0] != 'error')