from torch import nn
from torch.optim import SGD
import pickle
from skorch import NeuralNetClassifier
import numpy as np
import torch
from sklearn.ensemble import RandomForestClassifier
optimizer=SGD

class CNN(nn.Module):
    def __init__(self,input_dim,hidden_size,num_filter,output_dim,dropout):
        super().__init__()
        self.conv1 = nn.Conv1d(1,num_filter,3, padding = 1)
        self.conv2 = nn.Conv1d(num_filter,num_filter,3, padding = 1)
        self.conv3 = nn.Conv1d(num_filter,num_filter,3, padding = 1)
        self.maxpool1 = nn.MaxPool1d(2) 
        self.maxpool2 = nn.MaxPool1d(3) 
        self.conv4 = nn.Conv1d(num_filter,num_filter,3, padding = 1)
        self.flatten = nn.Flatten()
        self.dense = nn.Linear(int(num_filter*input_dim/6),hidden_size)
        self.drop = nn.Dropout(dropout)
        self.dense2 = nn.Linear(hidden_size,output_dim)
        self.prelu = nn.PReLU()
        self.softmax = nn.Softmax(dim=1)
        
    def forward(self,X):
        X = self.conv1(X)
        X = self.prelu(X)
        # X = self.conv2(X)
        # X = self.prelu(X)
        X = self.maxpool1(X)
        X = self.conv3(X)
        X = self.prelu(X)
        # X = self.conv4(X)
        # X = self.prelu(X)
        X = self.maxpool2(X)
        X = self.flatten(X)
        X = self.drop(X)
        X = self.dense(X)
        X = self.prelu(X)
        X = self.dense2(X)
        X = self.prelu(X)
        X = self.softmax(X)
        return X
    
class ANN_1(nn.Module):
    def __init__(self,input_dim,hidden_size,output_dim,dropout):
        super().__init__()
        self.dense = nn.Linear(input_dim,hidden_size)
        self.prelu = nn.PReLU()
        self.drop = nn.Dropout(dropout)
        self.dense2 = nn.Linear(hidden_size,output_dim)
        self.max = nn.Softmax(dim=1)
    def forward(self,X):
        return self.max(self.dense2(self.drop(self.prelu(self.dense(X)))))
    
class ANN_2(nn.Module):
    def __init__(self,input_dim,hidden_size_1,hidden_size_2,output_dim,dropout):
        super().__init__()
        self.dense = nn.Linear(input_dim,hidden_size_1)
        self.dense2 = nn.Linear(hidden_size_1,hidden_size_2)
        self.drop = nn.Dropout(dropout)
        self.prelu = nn.PReLU()
        self.dense3 = nn.Linear(hidden_size_2,output_dim)
        self.max = nn.Softmax(dim=1)
    def forward(self,X):
        X = self.dense(X)
        X = self.prelu(X)
        X = self.drop(X)
        X = self.dense2(X)
        X = self.prelu(X)
        X = self.dense3(X)
        X = self.max(X)
        return X
    
class HEHEHEHEHE:
    def __init__(self):
        self.models = [NeuralNetClassifier(module = CNN,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.4, 
                                           module__num_filter=48,module__hidden_size=40, max_epochs = 75,
                          lr = 0.02, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = CNN,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.4, 
                                           module__num_filter=32,module__hidden_size=40, max_epochs = 75,
                          lr = 0.02, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = CNN,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.4, 
                                           module__num_filter=48,module__hidden_size=20, max_epochs = 75,
                          lr = 0.02, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = ANN_1,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.3,
                                           module__hidden_size=90, max_epochs = 75,
                          lr = 0.1, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = ANN_1,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.3,
                                           module__hidden_size=70, max_epochs = 75,
                          lr = 0.1, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = ANN_2,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.3, 
                                           module__hidden_size_1=70,module__hidden_size_2=70, max_epochs = 75 ,
                          lr = 0.1, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = ANN_2,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.3, 
                                           module__hidden_size_1=50,module__hidden_size_2=50, max_epochs = 75 ,
                          lr = 0.1, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None),
                       NeuralNetClassifier(module = ANN_2,module__input_dim = 198,
                                           module__output_dim = 2, module__dropout = 0.3, 
                                           module__hidden_size_1=70,module__hidden_size_2=50, max_epochs = 75 ,
                          lr = 0.1, verbose = 0, optimizer = optimizer, 
                          device = "cuda" if torch.cuda.is_available() else "cpu",
                          criterion = nn.BCELoss, train_split=None)
                       ]
        self.second_stage = RandomForestClassifier()
    
    def fit(self, X_train, y_train):
        hehe=[]
        for a in range(8):
            if(a<3):
                self.models[a].fit(X_train,y_train)
                y_train_pred = self.models[a].predict(X_train)
                hehe.append(y_train_pred)
            else:
                X_hehehe=X_train.squeeze()
                self.models[a].fit(X_hehehe,y_train)
                y_train_pred = self.models[a].predict(X_hehehe)
                hehe.append(y_train_pred)
        y_super_train = np.array([0 if y_train[a][0]>y_train[a][1] else 1 for a in range(len(y_train))])
        X_second_stage = np.array([[0 if hehe[a][b][0]>hehe[a][b][1] else 1 for a in range(8)] for b in range(len(hehe[0]))])
        self.second_stage.fit(X_second_stage,y_super_train)

    
    def predict(self, X_test):
        res = []
        for a in range(8):
            if a<3:
                res.append(self.models[a].predict(X_test))
            else:
                if len(X_test)!=1:
                    X_hehehe=X_test.squeeze()
                else:
                    X_hehehe=X_test.squeeze().unsqueeze(0)
                res.append(self.models[a].predict(X_hehehe))
        # res2 = []
        # for a in range(len(res[0])):
        #     res2.append([0,0])
        #     for b in range(8):
        #         res2[-1][0]+=res[b][a][0]
        #         res2[-1][1]+=res[b][a][1]
        #     if res2[-1][1]>=res2[-1][0]:
        #         res2[-1]=1
        #     else:
        #         res2[-1]=0
        X_second_stage = np.array([[0 if res[a][b][0]>res[a][b][1] else 1 for a in range(8)] for b in range(len(res[0]))])
        res2 = self.second_stage.predict(X_second_stage)
        return np.array(res2)
    
def enn():
    with open('models/enn.pkl', 'rb') as f:
        model = pickle.load(f)
    return model